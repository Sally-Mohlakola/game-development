<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script>//Added this and it allowed to getContex</script>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden; background:#000000;
    display:flex; justify-content:center; align-items:center; height:100vh;
  }
  canvas { background:#7ebbfd; display:block; }
</style>

<title>Flappy Bird</title>
</head>
    <body>
        <canvas id="canvas" width="1330" height="550"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        let time=0;
        let frameNumber=0;
        let playerY=60;

        let gameState="READY";

        const player = {
          x:150,
          y:200,
          r:20,
          velocity:0,
          gravity:0.6,
          flap:-10

        }

        const pillarSpeed=3;
        const pillarGap=150;
        const pillarWidth=100;

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

/*
        document.addEventListener("keydown", (e)=>{

          if (e.key==="ArrowUp" || e.key===" "){
            if (gameState==="READY") 
              gameState="PLAYING";
            if (gameState==="PLAYING")
              player.velocity = player.flap;
          }

        });*/

        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });


        // Update function (game logic)
        function update() {
            if (keys.ArrowUp) playerY -= playerSpeed;
            if (keys.ArrowDown) playerY += playerSpeed;
            if (keys.ArrowLeft) playerX -= playerSpeed;
            if (keys.ArrowRight) playerX += playerSpeed;

            // Optional: Constrain movement within canvas boundaries
            playerX = Math.max(0, Math.min(canvas.width - playerSize, playerX));
            playerY = Math.max(0, Math.min(canvas.height - playerSize, playerY));
        }

        frameNumber++;

        function drawCircle(x, y, r, color){
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }


       function drawRect(x,y,color){
        ctx.fillStyle = color;
        ctx.fillRect(x,y,100,300);
       }


       function drawPillar(x,y){
        //const linearGradient = ctx.createLinearGradient(0, 0, W, 0);
        //linearGradient.addColorStop(0, 'hsl(120, 50%, 20%)');
        //linearGradient.addColorStop(0.1, 'hsl(120, 80%, 50%)');
        
        ctx.fillStyle='hsl(120, 80%, 45%)';
        ctx.strokeStyle="black";
        ctx.lineWidth=5;

        ctx.strokeRect(x,y,100,800);
        ctx.fillRect(x,y,100,800);
       
        ctx.strokeRect(x-40,y,180,50);
        ctx.fillRect(x-40,y,180,50);

        ctx.fillStyle="#60f378";
        ctx.fillRect(x,y+60,30,600);
        ctx.fillRect(x+40,y+60,10,600);
        ctx.fillRect(x-40,y,80,50);

        ctx.fillStyle="hsl(120, 80%, 20%)"
        ctx.fillRect(x+80,y+52,20,600);

        ctx.fillStyle="hsl(120,100%,20%)";
        ctx.fillRect(x+40,y,80,50);

        ctx.fillStyle="hsl(120,100%,100%)";
        ctx.fillRect(x,y,10,50);
        ctx.fillRect(x-15,y,10,50);

       }


       function drawUpsideDownPillar(x,y,offset){
        ctx.save();
        ctx.translate(x + W-1000, y+offset); 
        ctx.scale(1,-1);

        drawPillar(x,y);
        ctx.restore();
       }

       

      //Game logic

        function updateKeys() {
            if (keys.ArrowUp)
              playerY-=10;
            else{
              playerY+=1.5;
            }
        }

        pos=[-1400,-1600,-1800,-2000,-2200,-2400];
        let p=0;


        
          //drawPillar(1400-1400*(frameNumber%1000)/1000,300);
          //drawPillar(-1400*(frameNumber%2000)/2000,300);


        

        function topDownPair(height, spaceInBetweenOffset){
          drawUpsideDownPillar(-100,100,spaceInBetweenOffset);
          drawPillar(140,height);
        }

        pillars=[];
        heights = [145,275,345,220];

        function initPillars(){
          //top pillars
          pillars.forEach(p=>{ p.posiion.z+=0;  });// 
           for(let i=0;i<4;i++) pillars.push(drawPillar(140,heights[i]));
        }

         


        function pillarLoop(){
          heights = [145,275,345,220];
          spaces =  [0,130,200,75];

          let spacing = 1400-2560*(frameNumber%2400)/2400;
          
          let ret= true;


          

          for (let i=0; i<4; i++){
           
            ctx.save();
            ctx.translate(spacing,150);

            spacing+=300;
            topDownPair(heights[i],spaces[i]);
            ctx.restore();
          }

        
      }



      //player pos - position of pillar<0.4 break;

        function render(){
          ctx.clearRect(0, 0, W, H); 
          frameNumber++;
          pillarLoop();

          //if (playerY-)

         //topDownPair(220,75); //(height, spaceOffset); height=> pillarDown ; spaceOffset=> pillarDown
         
          drawCircle(150,playerY,20,"red");
        }

        function animate(ts){
          updateKeys();
          render();

          requestAnimationFrame(animate);

        }


       

      
        animate();
       

        
       //1bc907




    </script>
    </body>





</html>